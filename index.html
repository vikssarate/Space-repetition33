<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Image Occlusion</title>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<style>
:root{--bg:#0f1220;--card:#181c2f;--ink:#eef1ff;--muted:#9aa3c7;--line:#2a3052;--accent:#6ca8ff;--ok:#7bd88f;--bad:#ff7575}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;-webkit-tap-highlight-color:transparent}
header,footer{padding:12px 16px;display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap}
h1{margin:0;font-size:18px}
.badge{display:inline-flex;gap:6px;align-items:center;padding:4px 10px;border:1px solid var(--line);border-radius:9999px;color:var(--muted);font-size:12px}
.btn{appearance:none;border:1px solid var(--accent);background:transparent;color:var(--ink);padding:8px 12px;border-radius:10px;font-weight:600;cursor:pointer}
.btn:active{transform:scale(.98)}
.tabs{display:flex;gap:6px;flex-wrap:wrap}
.tab{border:1px solid var(--line);background:#0b1328;color:#cfd7ff;padding:8px 12px;border-radius:9999px;cursor:pointer}
.tab.active{outline:2px solid var(--accent)}
.wrap{max-width:980px;margin:0 auto;padding:10px 16px 60px}

/* Add tab layout */
.card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px;margin:10px 0}
.grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.grid>label{display:flex;flex-direction:column;gap:6px;font-size:12px;color:var(--muted)}
input[type="text"]{background:#0c1328;color:var(--ink);border:1px solid var(--line);border-radius:10px;padding:10px;font:inherit}
.small{font-size:12px;color:var(--muted)}
.chips{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px}
.chip{display:inline-flex;align-items:center;gap:6px;background:#0b1328;border:1px solid var(--line);border-radius:9999px;padding:4px 8px;font:600 12px/1 system-ui;color:#cfd7ff}
.chip button{border:none;background:transparent;color:#ff9a9a;cursor:pointer;font-weight:800}

/* Gallery */
.timeline{position:relative;margin:8px auto}
.gallery-card{position:relative;width:min(96%,780px);margin:20px auto 26px;padding:0;border:none;background:transparent}
.btnRow{position:absolute;top:-26px;right:-2px;display:flex;gap:6px;z-index:2}
.cardBtn{border:1px solid var(--line);background:var(--card);border-radius:999px;padding:4px 8px;font-size:12px;cursor:pointer;color:#ddd}
.cardBtn:hover{border-color:#9aa3c7}
#sentinel{height:1px}

/* Media + occlusion */
.mediaBox{width:100%;max-width:780px;margin:0 auto;position:relative}
.mediaImg{display:block;margin:0 auto;border-radius:14px;border:2px solid var(--line);max-height:520px;width:auto;max-width:100%;object-fit:contain;background:#0b1328}
.occlOverlay{position:absolute;inset:0}
.occlRect{fill:#0b0f22;fill-opacity:.86;stroke:#6ca8ff;stroke-width:2}
.occlRect.revealed{fill-opacity:.06;stroke:#7bd88f}

/* Occlusion Editor Modal */
body.modal-open{height:100%;overflow:hidden}
.modal{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;align-items:center;justify-content:center;z-index:10;padding:20px}
.modalCard{background:var(--card);border:1px solid var(--line);border-radius:16px;max-width:980px;width:100%;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.4);max-height:calc(100vh - 40px);overflow:auto;-webkit-overflow-scrolling:touch}
.modal h2{margin:0 0 8px 0;font-size:18px}
.row{display:flex;gap:8px;flex-wrap:wrap}
.occlStage{position:relative;max-width:100%;border:1px solid var(--line);border-radius:12px;overflow:hidden;background:#0b1328;touch-action:none;margin-top:10px}
.occlStage img{max-width:100%;display:block;user-select:none;-webkit-user-drag:none}
.modal .hint{font-size:12px;color:var(--muted);margin-top:6px}
hr{border:none;border-top:1px solid var(--line);margin:10px 0}
</style>
</head>
<body>
<header>
  <h1>Image Occlusion</h1>
  <div class="tabs">
    <button id="tabAdd" class="tab active">Add</button>
    <button id="tabGallery" class="tab">Gallery</button>
  </div>
  <div class="row">
    <button id="exportBtn" class="btn">Export</button>
    <label class="btn" style="cursor:pointer">Import
      <input id="importInp" type="file" accept=".json,application/json" hidden>
    </label>
  </div>
</header>

<div class="wrap">
  <!-- ADD TAB -->
  <section id="addPane" class="card">
    <div class="grid">
      <label>Image URLs
        <input id="urlInp" type="text" placeholder="https://… , https://…">
      </label>
      <label>Attach Images
        <input id="fileInp" type="file" accept="image/*" multiple>
        <span class="small">Compressed & stored in IndexedDB.</span>
      </label>
    </div>
    <div class="row" style="justify-content:flex-end;margin-top:8px">
      <button id="addBtn" class="btn">Add to Library</button>
    </div>
    <hr>
    <div class="small">Newly added (edit masks or remove):</div>
    <div id="chips" class="chips"></div>
  </section>

  <!-- GALLERY TAB -->
  <section id="galleryPane" class="card" style="display:none">
    <div class="small badge">Tip: In Gallery, tap a mask to remove it. Use “Reset” to restore masks for that image.</div>
    <div id="timeline" class="timeline"></div>
    <div id="sentinel"></div>
  </section>
</div>

<footer>
  <div class="badge">Data in localStorage • Images in IndexedDB • No server</div>
</footer>

<!-- Occlusion Editor Modal -->
<div id="occlModal" class="modal" role="dialog" aria-modal="true">
  <div class="modalCard">
    <h2>Occlusion Editor</h2>
    <div class="row">
      <button id="modeDraw" class="btn">Draw</button>
      <button id="modeErase" class="btn">Erase</button>
      <button id="clearAll" class="btn">Clear</button>
      <button id="doneBtn" class="btn" style="margin-left:auto">Done</button>
    </div>
    <div class="occlStage" id="occlStage">
      <img id="occlImg" alt="">
      <svg id="occlSvg" class="occlOverlay"></svg>
    </div>
    <div class="hint">Draw rectangles with mouse, finger, or Apple Pencil. In Erase mode, tap a rectangle to delete it.</div>
  </div>
</div>

<script>
/* ===================== Storage Keys ===================== */
const LSK   = 'imgOcc.items.v1';      // items metadata
const DB    = 'imgOcc.media.v1';      // IndexedDB store

/* ===================== Elements ===================== */
const tabAdd = document.getElementById('tabAdd');
const tabGallery = document.getElementById('tabGallery');
const addPane = document.getElementById('addPane');
const galleryPane = document.getElementById('galleryPane');

const urlInp = document.getElementById('urlInp');
const fileInp = document.getElementById('fileInp');
const addBtn = document.getElementById('addBtn');
const chips = document.getElementById('chips');

const exportBtn = document.getElementById('exportBtn');
const importInp = document.getElementById('importInp');

const timeline = document.getElementById('timeline');
const sentinel = document.getElementById('sentinel');

/* Occlusion Editor */
const occlModal = document.getElementById('occlModal');
const occlImg = document.getElementById('occlImg');
const occlSvg = document.getElementById('occlSvg');
const modeDraw = document.getElementById('modeDraw');
const modeErase = document.getElementById('modeErase');
const clearAll = document.getElementById('clearAll');
const doneBtn = document.getElementById('doneBtn');
const occlStage = document.getElementById('occlStage');

/* ===================== State ===================== */
let items = loadItems(); // [{id, created, src, masks:[{x,y,w,h,label?}]}]
let pool = [];           // for infinite scroll
let io = null;

let editingIndex = -1;   // index into items
let editMode = 'draw';   // 'draw' | 'erase'
let drawing = null;      // {x0,y0,rect}

/* ===================== IndexedDB helpers ===================== */
function openDB(name){
  return new Promise((res,rej)=>{
    const r = indexedDB.open(name,1);
    r.onupgradeneeded = ()=> {
      const db = r.result;
      if(!db.objectStoreNames.contains('media')) db.createObjectStore('media',{keyPath:'id'});
    };
    r.onsuccess = ()=> res(r.result);
    r.onerror = ()=> rej(r.error || new Error('IDB open failed'));
  });
}
async function idbPutBlob(kind, blob){
  const db = await openDB(DB);
  const id = `${kind}-${Date.now().toString(36)}-${Math.random().toString(36).slice(2,7)}`;
  await new Promise((res,rej)=>{
    const tx=db.transaction('media','readwrite');
    tx.oncomplete=()=>res();
    tx.onerror=()=>rej(tx.error);
    tx.objectStore('media').put({id, kind, mime: blob.type||'', created: Date.now(), blob});
  });
  db.close();
  return 'idb:'+id;
}
async function idbGetBlob(uri){
  const id = uri.slice(4);
  const db = await openDB(DB);
  const val = await new Promise((res,rej)=>{
    const tx=db.transaction('media','readonly');
    const g=tx.objectStore('media').get(id);
    g.onsuccess=()=>res(g.result);
    g.onerror=()=>rej(g.error);
  });
  db.close();
  if(!val) throw new Error('not found');
  return val.blob;
}
async function idbToDataURL(uri){
  const b = await idbGetBlob(uri);
  return await new Promise(res=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.readAsDataURL(b); });
}

/* ===================== Utils ===================== */
const toArr=v=>v==null?[]:(Array.isArray(v)?v:[v]);
const splitUrls=s=>!s?[]:s.split(',').map(x=>x.trim()).filter(Boolean);
function fmtLabel(u){
  if(typeof u==='string' && u.startsWith('idb:')) return 'IDB image';
  return String(u).length>42 ? '…'+String(u).slice(-42) : String(u);
}
function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }
function genId(){ return Date.now().toString(36)+Math.random().toString(36).slice(2,7); }
async function compressImageToBlob(file, maxDim=1600, quality=.78){
  const url = URL.createObjectURL(file);
  const img = await new Promise((r,j)=>{const i=new Image(); i.onload=()=>r(i); i.onerror=j; i.src=url;});
  URL.revokeObjectURL(url);
  const scale = Math.min(1, maxDim / Math.max(img.width, img.height));
  const w = Math.round(img.width*scale), h = Math.round(img.height*scale);
  const c=document.createElement('canvas'); c.width=w; c.height=h;
  const ctx=c.getContext('2d'); ctx.drawImage(img,0,0,w,h);
  return await new Promise(res=> c.toBlob(b=>res(b), 'image/jpeg', quality));
}

/* ===================== Load/Save ===================== */
function loadItems(){
  try{
    const raw = JSON.parse(localStorage.getItem(LSK)||'[]');
    return Array.isArray(raw) ? raw : [];
  }catch{return [];}
}
function saveItems(){ localStorage.setItem(LSK, JSON.stringify(items)); }

/* ===================== Tabs ===================== */
function showTab(which){
  if(which==='add'){
    addPane.style.display='block';
    galleryPane.style.display='none';
    tabAdd.classList.add('active'); tabGallery.classList.remove('active');
  }else{
    addPane.style.display='none';
    galleryPane.style.display='block';
    tabGallery.classList.add('active'); tabAdd.classList.remove('active');
    // rebuild pool for infinite scroll when opening gallery
    rebuildGallery();
  }
}
tabAdd.onclick=()=>showTab('add');
tabGallery.onclick=()=>showTab('gallery');

/* ===================== Add Tab ===================== */
function renderChips(){
  chips.innerHTML='';
  if(!items.length){ chips.innerHTML='<span class="small">— empty —</span>'; return; }
  // Show last 10 added
  const last = [...items].sort((a,b)=>b.created-a.created).slice(0,10);
  last.forEach((it, idx)=>{
    const s=document.createElement('span'); s.className='chip';
    s.innerHTML = `<span>${fmtLabel(it.src)} • ${it.masks?.length||0} mask(s)</span>
      <button class="edit" title="Edit">✎</button>
      <button class="del" title="Remove">×</button>`;
    s.querySelector('.edit').onclick=()=>openEditor(items.findIndex(x=>x.id===it.id));
    s.querySelector('.del').onclick =()=>{ const i=items.findIndex(x=>x.id===it.id); if(i>-1){ items.splice(i,1); saveItems(); renderChips(); } };
    chips.appendChild(s);
  });
}
renderChips();

addBtn.onclick=async()=>{
  // Add URLs
  const urls = splitUrls(urlInp.value);
  urls.forEach(u=> items.push({ id:genId(), created:Date.now(), src:u, masks:[] }));
  urlInp.value='';

  // Add files
  for(const file of toArr(fileInp.files)){
    const blob = await compressImageToBlob(file);
    const uri = await idbPutBlob('img', blob);
    items.push({ id:genId(), created:Date.now(), src:uri, masks:[] });
  }
  fileInp.value='';
  saveItems();
  renderChips();
};

/* ===================== Gallery (infinite scroll) ===================== */
function rebuildGallery(){
  timeline.innerHTML=''; pool.length=0;
  const sorted = [...items].sort((a,b)=>b.created - a.created);
  pool.push(...sorted);
  if(io) io.disconnect();
  io = new IntersectionObserver(es=>{
    if(es.some(e=>e.isIntersecting)) loadMore();
  }, {root:null, rootMargin:'900px 0', threshold:0});
  io.observe(sentinel);
  loadMore();
}
const CHUNK=8;
function loadMore(){
  const n=Math.min(CHUNK, pool.length);
  const slice=pool.splice(0,n);
  slice.forEach(renderGalleryCard);
}

function renderGalleryCard(it){
  const card=document.createElement('div'); card.className='gallery-card';

  /* Buttons */
  const btnRow=document.createElement('div'); btnRow.className='btnRow';
  const editBtn=document.createElement('button'); editBtn.className='cardBtn'; editBtn.textContent='✎ Edit'; editBtn.onclick=()=>openEditor(items.findIndex(x=>x.id===it.id));
  const resetBtn=document.createElement('button'); resetBtn.className='cardBtn'; resetBtn.textContent='Reset';
  const delBtn=document.createElement('button'); delBtn.className='cardBtn'; delBtn.textContent='🗑 Delete';

  btnRow.append(editBtn, resetBtn, delBtn);

  const box=document.createElement('div'); box.className='mediaBox';
  const img=document.createElement('img'); img.className='mediaImg';
  const svg=document.createElementNS('http://www.w3.org/2000/svg','svg'); svg.classList.add('occlOverlay');

  box.append(img, svg);
  card.append(btnRow, box);
  timeline.appendChild(card);

  const stateMasks = (it.masks||[]).map(m=>({...m, revealed:false}));

  const draw=()=>{
    const W=img.clientWidth, H=img.clientHeight;
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
    svg.innerHTML='';
    stateMasks.forEach(m=>{
      const r=document.createElementNS('http://www.w3.org/2000/svg','rect');
      r.setAttribute('x', m.x*W); r.setAttribute('y', m.y*H);
      r.setAttribute('width', m.w*W); r.setAttribute('height', m.h*H);
      r.classList.add('occlRect'); if(m.revealed) r.classList.add('revealed');
      r.addEventListener('click', ()=>{ // tap to remove mask
        m.revealed = true; r.classList.add('revealed');
      }, {passive:true});
      svg.appendChild(r);
    });
  };

  resetBtn.onclick=()=>{ stateMasks.forEach(m=>m.revealed=false); draw(); };
  delBtn.onclick=()=>{ const ix=items.findIndex(x=>x.id===it.id); if(ix>-1){ items.splice(ix,1); saveItems(); card.remove(); } };

  // Load the image
  const setImg = (src)=>{
    img.onload=draw;
    img.src = src;
  };
  if(typeof it.src==='string' && it.src.startsWith('idb:')){
    idbGetBlob(it.src).then(b=> setImg(URL.createObjectURL(b))).catch(()=>{});
  }else setImg(it.src);

  // Redraw on resize for accurate scaling
  const ro = new ResizeObserver(()=> draw());
  ro.observe(img);
}

/* ===================== Editor ===================== */
function openEditor(index){
  editingIndex = index;
  const it = items[index];
  if(!it) return;

  // Show modal
  occlModal.style.display='flex';
  document.body.classList.add('modal-open');

  // Load image
  const setImg=(src)=>{ occlImg.onload=()=>{ drawEditor(); }; occlImg.src=src; };
  if(typeof it.src==='string' && it.src.startsWith('idb:')){
    idbGetBlob(it.src).then(b=> setImg(URL.createObjectURL(b))).catch(()=>{});
  }else setImg(it.src);

  setMode('draw');
}
function closeEditor(){
  occlModal.style.display='none';
  document.body.classList.remove('modal-open');
}

function setMode(m){
  editMode = m;
  modeDraw.style.outline = (m==='draw') ? '2px solid var(--accent)' : 'none';
  modeErase.style.outline = (m==='erase') ? '2px solid var(--accent)' : 'none';
}
modeDraw.onclick = ()=> setMode('draw');
modeErase.onclick = ()=> setMode('erase');

clearAll.onclick = ()=>{
  const it = items[editingIndex]; if(!it) return;
  if(confirm('Delete all masks for this image?')){ it.masks=[]; saveItems(); drawEditor(); }
};
doneBtn.onclick = ()=> closeEditor();

function drawEditor(){
  const it = items[editingIndex]; if(!it || !occlImg.src) { occlSvg.innerHTML=''; return; }
  const W=occlImg.clientWidth, H=occlImg.clientHeight;
  occlSvg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  occlSvg.innerHTML='';
  (it.masks||[]).forEach((m, idx)=>{
    const r=document.createElementNS('http://www.w3.org/2000/svg','rect');
    r.setAttribute('x', m.x*W); r.setAttribute('y', m.y*H);
    r.setAttribute('width', m.w*W); r.setAttribute('height', m.h*H);
    r.classList.add('occlRect');
    if(editMode==='erase'){
      r.addEventListener('pointerdown', e=>{
        // remove this mask
        it.masks.splice(idx,1);
        saveItems(); drawEditor();
      });
    }
    occlSvg.appendChild(r);
  });
}
function editorPoint(ev){
  const r=occlImg.getBoundingClientRect();
  const x=(ev.clientX - r.left)/r.width;
  const y=(ev.clientY - r.top )/r.height;
  return {x:clamp(x,0,1), y:clamp(y,0,1)};
}

// Pointer events for drawing
occlSvg.addEventListener('pointerdown', ev=>{
  if(editMode!=='draw' || !occlImg.src) return;
  ev.preventDefault();
  occlSvg.setPointerCapture(ev.pointerId);
  const p=editorPoint(ev), W=occlImg.clientWidth, H=occlImg.clientHeight;
  const rect=document.createElementNS('http://www.w3.org/2000/svg','rect');
  rect.classList.add('occlRect');
  rect.setAttribute('x', p.x*W); rect.setAttribute('y', p.y*H);
  rect.setAttribute('width', 1); rect.setAttribute('height', 1);
  occlSvg.appendChild(rect);
  drawing={x0:p.x, y0:p.y, rect};
});
occlSvg.addEventListener('pointermove', ev=>{
  if(!drawing) return;
  const p=editorPoint(ev), W=occlImg.clientWidth, H=occlImg.clientHeight;
  const x=Math.min(drawing.x0, p.x), y=Math.min(drawing.y0, p.y);
  const w=Math.abs(p.x-drawing.x0), h=Math.abs(p.y-drawing.y0);
  drawing.rect.setAttribute('x', x*W);
  drawing.rect.setAttribute('y', y*H);
  drawing.rect.setAttribute('width',  Math.max(2, w*W));
  drawing.rect.setAttribute('height', Math.max(2, h*H));
});
function finishDraw(){
  if(!drawing) return;
  const it = items[editingIndex]; if(!it) { drawing=null; return; }
  const W=occlImg.clientWidth, H=occlImg.clientHeight;
  const x=+drawing.rect.getAttribute('x')/W;
  const y=+drawing.rect.getAttribute('y')/H;
  const w=+drawing.rect.getAttribute('width')/W;
  const h=+drawing.rect.getAttribute('height')/H;
  drawing.rect.remove();
  if(w>0.002 && h>0.002){
    it.masks = it.masks || [];
    it.masks.push({x,y,w,h});
    saveItems();
  }
  drawing=null; drawEditor();
}
occlSvg.addEventListener('pointerup', finishDraw);
occlSvg.addEventListener('pointercancel', finishDraw);

/* ===================== Export / Import ===================== */
exportBtn.onclick = async ()=>{
  const out=[];
  for(const it of items){
    let srcOut = it.src;
    if(typeof srcOut==='string' && srcOut.startsWith('idb:')){
      try{ srcOut = await idbToDataURL(srcOut); }catch{}
    }
    out.push({src:srcOut, masks:it.masks||[], created:it.created||Date.now()});
  }
  const blob=new Blob([JSON.stringify(out,null,2)],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='image-occlusion-export.json'; a.click(); URL.revokeObjectURL(url);
};
importInp.onchange = async ()=>{
  const f = importInp.files?.[0]; if(!f) return;
  try{
    const txt = await f.text(); const arr = JSON.parse(txt);
    if(!Array.isArray(arr)) throw new Error('JSON must be an array');
    for(const o of arr){
      let src = o.src;
      if(typeof src==='string' && src.startsWith('data:')){
        const b = await (await fetch(src)).blob();
        src = await idbPutBlob('
